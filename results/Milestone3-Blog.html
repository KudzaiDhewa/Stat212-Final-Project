<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Milestone3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Milestone3-Blog_files/libs/clipboard/clipboard.min.js"></script>
<script src="Milestone3-Blog_files/libs/quarto-html/quarto.js"></script>
<script src="Milestone3-Blog_files/libs/quarto-html/popper.min.js"></script>
<script src="Milestone3-Blog_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Milestone3-Blog_files/libs/quarto-html/anchor.min.js"></script>
<link href="Milestone3-Blog_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Milestone3-Blog_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Milestone3-Blog_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Milestone3-Blog_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Milestone3-Blog_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Milestone3</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="importance-of-topic" class="level2">
<h2 class="anchored" data-anchor-id="importance-of-topic">Importance of topic</h2>
<p>For PUBG players or those interested in becoming one, such as our group, it is helpful to have statistical data for strategic game play.</p>
<p>We have 3 broad questions that serve the topics of player performance analysis, weapon mastery analysis, and hot drop analysis. These three areas of game play can provide a more comprehensive understanding of the gaming dynamics and mechanics, improving the overall experience for a player.</p>
<p>A visual analysis of performance and preference can assist in creating a more personalized and engaging experience for players by allowing developers to refine game mechanics, ensuring fairness, competitiveness, and satisfaction across the various modes. Also, insights into hot drop zones and weapon mastery, for instance, can help ensure balanced resource allocation and gameplay dynamics.</p>
<p>Moreover, players are more likely to remain engaged when they see tangible opportunities and improvements for growth. Developers may be able to anticipate and address player needs with shared strategies, meta-analysis, and cultural elements like popular landing zones derived from the data visuals.</p>
<p>The overall growing popularity of esports and competitive gaming, understanding player success predictors, optimal strategies for different modes, and popular battlegrounds can provide teams and players with critical strategic advantages. It also enhances the viewing experience by spotlighting key action areas and emergent gameplay trends.</p>
</section>
<section id="rationale-of-narrowing-the-scope-of-our-questions" class="level2">
<h2 class="anchored" data-anchor-id="rationale-of-narrowing-the-scope-of-our-questions">Rationale of narrowing the scope of our questions</h2>
<p>PUBG is a survival game and therefore, a dive deep into how long into a match a player survived, or more importantly, what actions they took to survive near the end of the match, will hopefully shed light on a specific set of skills or strategies a new player can apply to avoid being eliminated for as long as possible. This resonates deeply with our third question where it asks about the most typical behaviors among players. Specifically, a thorough analysis of whether or not these behaviors can help lengthen a player’s survival time can help us come up with some visualizations that show the relationship between survival time and some factor(s) that contribute(s) negatively/positively to overall game performance.</p>
<p>Lifetime statistics give us an overview of the player’s performances over the course of their PUBG career. An analysis of this data would be critical in helping the game developers understand how well people are doing on different aspects of the game i.e.&nbsp;game modes and thereby informing any improvements that could be made to enhance the gaming experience but also retain players. This is why one of our broad questions focuses on drawing insights from this data concentrating mainly on performances of the players across different game modes.</p>
<p>Finally, the weapon mastery allows players to observe a preferred game-play throughout the population. It could give an insight into which weapons tend to yield good game play and vice versa. The weapons endpoint analysis may also guide new players choices when starting out in the game. It is a subset of many other endpoints that are beneficial for gameplay, with the main purpose being tool uses.</p>
</section>
<section id="plotsmodeling-output-connection-to-our-questions" class="level2">
<h2 class="anchored" data-anchor-id="plotsmodeling-output-connection-to-our-questions">Plots/Modeling output &amp; Connection to our questions</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kills.png" class="img-fluid figure-img"></p>
<figcaption>Hanna’s Viz</figcaption>
</figure>
</div>
<p>This visualization generally shows whether total kills and damage rates have any type of relationship per each weapon, for a single sample player. From the above plot, we can see that they have a moderately strong positive correlation.</p>
<p>This suggests that higher damage with a weapon is often associated with a higher kill count, indicating that weapon effectiveness could be a stronger predictor of a player’s success. By incorporating mastery levels and playstyle, you could refine predictive models for kill counts, win probabilities, and survival times. Furthermore, this data can also be expanded by stratifying it by game modes (solo, duo, squad). For instance, it would help identify whether the correlation between damage and kills is stronger in team modes (where players may rely on coordinated attacks) versus solo modes. This might reveal differences in weapon mastery and playstyle effectiveness across modes.</p>
<p>While this chart does not directly relate to hot-drop behaviors, a similar analysis could be conducted to compare damage and kills across different landing zones to identify high-risk, high-reward areas and their impact on player performance.</p>
<p>This chart’s insights could form the basis of a broader analysis addressing these questions by integrating additional variables like game modes, location data, and historical trends.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="survival.png" class="img-fluid figure-img"></p>
<figcaption>Kudzai_Viz</figcaption>
</figure>
</div>
<p>This visualization explores how well players perform across different game modes, classified into two main categories: Solo Play and Team Play. The first heatmap shows win rates, while the second focuses on survival rates.</p>
<p>From the heatmap, we observe that win rates are generally higher for team-based play compared to solo play. This suggests that players benefit from teamwork, which likely enhances coordination and overall performance, leading to more frequent victories.</p>
<p>However, when it comes to survival rates—a measure of how long players last before being killed—we notice a different trend. Players in solo modes tend to have comparable or even slightly better survival rates in some cases. This could indicate that in solo modes, players adopt a more cautious or defensive playstyle, focusing on surviving as long as possible without relying on team support. Conversely, team play may encourage more aggressive strategies, where players take risks knowing they have teammates to back them up.</p>
<p>These patterns highlight the trade-offs between the two categories: team play offers better odds of winning, while solo play may encourage more strategic survival.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="knocks.png" class="img-fluid figure-img"></p>
<figcaption>Tam’s Viz</figcaption>
</figure>
</div>
<p>This visualization is a boxplot that shows a positive relationship between the amount of damage a player dealt and the number of knocks they made, which makes sense because a large damage has to be made in order to get another player knocked.</p>
<p>For context, when a player is hit and runs out of their current HP, they are knocked. During this time, they are incapable of performing any activities other than crawling on the ground and waiting for their teammate to come and revive them. If no one comes and the countdown finishes, the player will be officially eliminated.</p>
<p>We hypothesize that a greater number of knocks mean a player is confident in his skills and is more likely to participate in combats, or even becomes proactive in hunting down their enemies. This can go both ways. If someone has a tendency to participate in combats, they have a higher likelihood to be hit and eliminated or, in contrast, because they are skilful and can instead eliminate most other players, they are more likely to make one of the top spots. Another possibility is that if someone refrains from combat and hides themselves really well, it is probable they make it deep into the match. For this reason, a further comparison between survival time and number of knocks can tell us which of these possibilities is more likely to happen, or it will be different depending on game mode.</p>
</section>
<section id="main-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="main-takeaways">Main Takeaways</h2>
<p>With our data story-telling project, we aim to better understand and share the “guide” in how to play PUBG more efficiently, if ranking is of the player’s goal. Players may find more success in leveling up in certain game modes, and having the knowledge of all the weapons in the game in an easy to read break-down may be incredibly helpful.</p>
</section>
<section id="limitations-ethical-considerations" class="level2">
<h2 class="anchored" data-anchor-id="limitations-ethical-considerations">Limitations &amp; Ethical considerations</h2>
<p>Blind people can’t see the charts</p>
<p>Charts are colorblind people friendly</p>
<p>The nature of the game involves violence and gun use, therefore in our visualizations, we will try to avoid the usage of any sensitive or triggering language.</p>
</section>
<section id="future-directions" class="level2">
<h2 class="anchored" data-anchor-id="future-directions">Future directions</h2>
<p>Integrate all our different visualizations into one digital artifact to tell a story about players’ performances (hopefully also using plotly which we learned in class!).</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>